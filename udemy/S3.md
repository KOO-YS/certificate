# S3

- 무한 확장 가능한 스토리지 → 크기를 사전에 정의할 필요가 없음
- 객체를 저장하게 해주는 시스템이자 서비스
- 파일이 버킷 or 디렉토리에 있으며 각 버킷은 globally 고유 이름을 가진다

<br>

## Buckets

- S3는 전역 서비스이지만 buckets은 리전 리소스
- **명명 규칙**
    - 대문자 포함 금지
    - 밑줄(_)을 사용하지 말 것
    - 길이 : 3 ~ 63 characters long
    - IP 주소 사용 금지
    - 소문자/숫자 중에서 시작
- **Objects**
    - 객체는 파일이며, 키를 가진다 → 파일의 전체 경로로 사용
    - 키의 구성 : prefix + object name
    - 버킷은 디렉토리 개념 없이 키 이름만 길다
        - s3은 ‘/’를 가진 매우 긴 이름의 키만 가지고 있다 (디렉토리 x)
    - 객체의 최대 크기는 5TB
        - 한 번에 5TB 업로드 불가 → 쪼개서 각각 업로드 : 멀티파트 업로드
    - 시스템, 사용자 관련 메타데이터 사용 → 키-밸류 쌍 리스트
    - 보안과 수명 주기 관련해서는 태그 사용 → 유니코드 키-밸류 쌍 10개 이하
- **객체 파일을 여는 법**
    1. 객체 상세 페이지에 들어가서 Object action 탭 > Open 클릭
    2. 객체 상세 페이지의 공용 오브젝트 URL 사용
        - 기본 Obejct URL에 접근하면 접근 거부를 반환할 것 → 버킷은 공용이 아니기 때문
        - 미리 서명된 URL 필요 → 임시 보안 인증 제공
- **Version ID**

<br>

## Versioning

- S3 파일을 버저닝 하기 위해서는 버킷 레벨에서 활성화가 될 필요
    - 같은 키로 파일 버전을 다시 업로드하는 경우,
        - ~~기존 파일을 덮어 쓴다~~ X
        - 해당 파일의 새로운 버전을 생성 O
- 버킷을 버저닝하면 모든 파일 버전을 어느 정도 유지하는 것이 가장 좋은 방법
    - 원치 않은 삭제로부터 보호받을 수 있기 때문
    - 이전 버전을 복원할 수 있기 때문
    - 필요한 이전 버전으로 손쉽게 되돌릴 수 있다
- 버저닝을 활성화하기 전, 버전 관리 되지 않은 파일 → null 버전
- 버킷의 버저닝을 중단할 경우
    - 이전 버전을 삭제 X
    - 이후의 파일이 버전을 할당받지 못하도록 O

<br>

## S3 Encryption for Objects

- s3에 객체를 업로드할 경우 AWS 내의 서버가 되므로 객체로의 접근을 보호

**S3에서 객체 암호화를 위한 4가지 방법**

- SSE-E3 : AWS가 처리 및 관리하는 키를 사용해 S3 객체를 암호화하는 방법
- SSE-KMS : AWS 키 관리 서비스를 사용해서 암호화 키를 관리하는 방법
- SSE-C : 사용자가 만든 암호화 키를 관리할 때 사용하는 방법
- 클라이언트 측 암호화


---

<br>

### SSE-E3

- Amazon S3에서 처리하고 관리하는 키를 암호화에 사용하는 방식
- 객체는 서버 측에서 암호화(SSE : Server Side Encryption)
- 암호화 유형 : AES-256 알고리즘
    
    ```json
    // 헤더 설정
    // x-azm (x Amazon)
    "x-amz-server-side- encryption":"AE256"
    ```
    
- S3에 객체를 업로드 하면 HTTP, HTTPS 프로토콜을 사용할 수 있으며, 상단 헤더를 추가
- 헤더를 통해 고유의 S3 관리 데이터 키를 사용해야 한다는 사실을 인식하고 S3 관리 데이터 키와 객체를 사용해서 암호화가 이루어진다
    - 그 후 객체는 암호화되어 Amazon S3 버킷에 저장
- 간단하나, S3에서 데이터 키를 전부 소유 및 관리

<br>


### SSE-KMS

- KMS : 키 관리 서비스 → 암호화 서비스들 중 하나
    - SSE-KMS에서의 암호화 키는 KMS에서 처리 및 관리
- 누가 어떤 키에 접근할 수 있을지 제어 가능하고 감사 추적 가능
- 각각의 객체는 마찬가지로 서버 측에서 암호화되며 이를 위해서는 헤더를 설정할 때 x Amazon 서버 측 암호화 값을 “aws:kms”로 지정
- SSE-S3와 같이 객체가 있으면 HTTPS와 헤더를 사용해 업로드
- 헤더를 통해 S3은 미리 정의해 둔 KMS 고객 마스터 키를 사용
- 고객 마스터 키를 사용하면 즉 지정된 키와 객체를 사용하면 암호화가 이루어지고 파일은 SSE-KMS 암호화 방식 하에 S3 버킷에 저장

<br>


### SSE-C

- AWS가 외부에서 고객이 관리하는 키 사용
- S3이 고객이 제공한 암호화 키를 저장하지 않음
    - 키를 사용한 후에 폐기
- 데이터를 AWS로 전송할 때는 HTTPS를 사용
    - AWS로 암호를 전달할테니 전송되는 동안 암호화가 반드시 필요
- 암호화 키가 HTTP 헤더에 제공되어야 하는데 모든 HTTP 요청마다 매번 제공 (항상 사용 후 폐기되기 때문)
- S3는 처음과 동일한 객체 및 클라이언트 제공 데이터 키를 받고, 서버 측 암호화로써 암호화된 객체를 S3 버킷에 저장
- 재사용을 위해서는 기존에 사용된 것과 동일한 클라이언트 측 데이터 키를 제공해야만 한다

<br>


### 클라이언트 측 암호화 CSE

- S3에 객체를 업로드하기 전 클라이언트가 객체를 암호화
- 클라이언트 라이브러리 사용 가능 ex = Amazon S3 Encryption Client
- 클라이언트는 데이터를 보내기 전 암호화 해야하고, 전달받은 데이터가 CSE를 사용해 암호화되었다면 데이터를 해독할 책임도 전적으로 사용자에게 있음
- 키와 암호화 주기 전체를 클라이언트가 전부 관리