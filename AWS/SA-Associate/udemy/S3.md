# S3

- 무한 확장 가능한 스토리지 → 크기를 사전에 정의할 필요가 없음
- 객체를 저장하게 해주는 시스템이자 서비스
- 파일이 버킷 or 디렉토리에 있으며 각 버킷은 globally 고유 이름을 가진다

<br>

## Buckets

- S3는 전역 서비스이지만 buckets은 리전 리소스
- **명명 규칙**
    - 대문자 포함 금지
    - 밑줄(_)을 사용하지 말 것
    - 길이 : 3 ~ 63 characters long
    - IP 주소 사용 금지
    - 소문자/숫자 중에서 시작
- **Objects**
    - 객체는 파일이며, 키를 가진다 → 파일의 전체 경로로 사용
    - 키의 구성 : prefix + object name
    - 버킷은 디렉토리 개념 없이 키 이름만 길다
        - s3은 ‘/’를 가진 매우 긴 이름의 키만 가지고 있다 (디렉토리 x)
    - 객체의 최대 크기는 5TB
        - 한 번에 5TB 업로드 불가 → 쪼개서 각각 업로드 : 멀티파트 업로드
    - 시스템, 사용자 관련 메타데이터 사용 → 키-밸류 쌍 리스트
    - 보안과 수명 주기 관련해서는 태그 사용 → 유니코드 키-밸류 쌍 10개 이하
- **객체 파일을 여는 법**
    1. 객체 상세 페이지에 들어가서 Object action 탭 > Open 클릭
    2. 객체 상세 페이지의 공용 오브젝트 URL 사용
        - 기본 Obejct URL에 접근하면 접근 거부를 반환할 것 → 버킷은 공용이 아니기 때문
        - 미리 서명된 URL 필요 → 임시 보안 인증 제공
- **Version ID**

<br>

## Versioning

- S3 파일을 버저닝 하기 위해서는 버킷 레벨에서 활성화가 될 필요
    - 같은 키로 파일 버전을 다시 업로드하는 경우,
        - ~~기존 파일을 덮어 쓴다~~ X
        - 해당 파일의 새로운 버전을 생성 O
- 버킷을 버저닝하면 모든 파일 버전을 어느 정도 유지하는 것이 가장 좋은 방법
    - 원치 않은 삭제로부터 보호받을 수 있기 때문
    - 이전 버전을 복원할 수 있기 때문
    - 필요한 이전 버전으로 손쉽게 되돌릴 수 있다
- 버저닝을 활성화하기 전, 버전 관리 되지 않은 파일 → null 버전
    - null 버전 파일이 있는 상태에서 버전을 활성화한다면, 그대로 이어서 버저닝 가능
- 버킷의 버저닝을 중단할 경우
    - 이전 버전을 삭제 X
    - 이후의 파일이 버전을 할당받지 못하도록 O
    - 중단 후 파일을 삭제하면 Delete Marker(삭제 마커)가 생겨서 파일을 실제로 삭제하지 않고, 표시만 해둠
        - 삭제 마커에도 고유의 버전 ID가 존재하며 크기는 0 byte

<br>

## S3 Encryption for Objects

- s3에 객체를 업로드할 경우 AWS 내의 서버가 되므로 객체로의 접근을 보호

**S3에서 객체 암호화를 위한 4가지 방법**

- SSE-E3 : AWS가 처리 및 관리하는 키를 사용해 S3 객체를 암호화하는 방법
- SSE-KMS : AWS 키 관리 서비스를 사용해서 암호화 키를 관리하는 방법
- SSE-C : 사용자가 만든 암호화 키를 관리할 때 사용하는 방법
- 클라이언트 측 암호화

<br>

### ➕ TIP : 통신 중 암호화 (Encryption in transit - SSL/TLS)

- S3은 암호화되지 않은 상태의 HTTP 엔드포인트를 노출, 암호화된 HTTPS 엔드포인트를 노출해 전송 중 암호화 서비스를 제공
    - SSL와 TLS 인증서의 도움
- 원하는 엔드 포인트를 선택할 수 있으나, 대부분 HTTPS를 권장
- SSE-C를 사용해 클라이언트가 키를 제공하는 경우, HTTPS 사용이 의무

<br>

---

<br>

### SSE-S3

- Amazon S3에서 처리하고 관리하는 키를 암호화에 사용하는 방식
- 객체는 서버 측에서 암호화(SSE : Server Side Encryption)
- 암호화 유형 : AES-256 알고리즘
    
    ```json
    // 헤더 설정
    // x-azm (x Amazon)
    "x-amz-server-side- encryption":"AE256"
    ```
    
- S3에 객체를 업로드 하면 HTTP, HTTPS 프로토콜을 사용할 수 있으며, 상단 헤더를 추가
- 헤더를 통해 고유의 S3 관리 데이터 키를 사용해야 한다는 사실을 인식하고 S3 관리 데이터 키와 객체를 사용해서 암호화가 이루어진다
    - 그 후 객체는 암호화되어 Amazon S3 버킷에 저장
- 간단하나, S3에서 데이터 키를 전부 소유 및 관리

<br>


### SSE-KMS

- KMS : 키 관리 서비스 → 암호화 서비스들 중 하나
    - SSE-KMS에서의 암호화 키는 KMS에서 처리 및 관리
- 누가 어떤 키에 접근할 수 있을지 제어 가능하고 감사 추적 가능
- 각각의 객체는 마찬가지로 서버 측에서 암호화되며 이를 위해서는 헤더를 설정할 때 x Amazon 서버 측 암호화 값을 “aws:kms”로 지정
- SSE-S3와 같이 객체가 있으면 HTTPS와 헤더를 사용해 업로드
- 헤더를 통해 S3은 미리 정의해 둔 KMS 고객 마스터 키를 사용
- 고객 마스터 키를 사용하면 즉 지정된 키와 객체를 사용하면 암호화가 이루어지고 파일은 SSE-KMS 암호화 방식 하에 S3 버킷에 저장

<br>


### SSE-C

- AWS가 외부에서 고객이 관리하는 키 사용
- S3이 고객이 제공한 암호화 키를 저장하지 않음
    - 키를 사용한 후에 폐기
- 데이터를 AWS로 전송할 때는 HTTPS를 사용
    - AWS로 암호를 전달할테니 전송되는 동안 암호화가 반드시 필요
- 암호화 키가 HTTP 헤더에 제공되어야 하는데 모든 HTTP 요청마다 매번 제공 (항상 사용 후 폐기되기 때문)
- S3는 처음과 동일한 객체 및 클라이언트 제공 데이터 키를 받고, 서버 측 암호화로써 암호화된 객체를 S3 버킷에 저장
- 재사용을 위해서는 기존에 사용된 것과 동일한 클라이언트 측 데이터 키를 제공해야만 한다

<br>


### 클라이언트 측 암호화 CSE

- S3에 객체를 업로드하기 전 클라이언트가 객체를 암호화
- 클라이언트 라이브러리 사용 가능 ex = Amazon S3 Encryption Client
- 클라이언트는 데이터를 보내기 전 암호화 해야하고, 전달받은 데이터가 CSE를 사용해 암호화되었다면 데이터를 해독할 책임도 전적으로 사용자에게 있음
- 키와 암호화 주기 전체를 클라이언트가 전부 관리

<br>

## S3 Security

**User based : 사용자 기반 보안**

- IAM 정책은 사용자가 어떤 API 호출이 허용될지를 결정
- 사용자가 IAM 정책을 통해 Amazon S3 버킷으로의 액세스 방법을 승인받게 되면 실행이 가능해짐

**Resource Based : 리소스 기반 보안**

- S3 콘솔에서 설정 가능한 버킷 전반의 규칙
- S3 버킷에서 보안 주체가 무엇을 할 수 있는지/할 수 없는지 결정하는 정책
- 이를 통해 S3 버킷으로의 교차 계정 액세스가 활성화
- ACL 방식
    - 객체 레벨에서의 액세스 규칙을 설정
- 버킷 ACL 방식


<br>


---

- IAM 보안 주체인 유저 나 역할 등은 IAM 권한이 허용할 경우에 S3 객체에 액세스 가능
- 버킷에 사용자 액세스 명시적 거부가 없어야함
- 버킷 정책이 사용자 액세스를 명시적으로 거부한다면 액세스 불가능

### 블록 퍼블릭 액세스 버킷 설정 : Bucket settings for Block Public Access

- 객체가 퍼블릭화 되는 것을 차단하는 설정
- 계정에 제한이 있을 경우에 사용
- 퍼블릭 액세스 차단 설정 종류
    - new access control lists (ACLs) : 새 액세스 제어 목록
    - any access control lists (ACLs) : 모든 액세스 제어 목록
    - new public bucket or access point policies : 새 퍼블릭 또는 액세스 포인트 정책
- 객체와 버킷이 외부로 공개되지 않도록 차단할 수 있게 된다
- 퍼블릭 버킷이나 액세스 포인트 정책을 통해 버킷과 객체를 향한 퍼블릭 및 교차 계정 액세스를 막을 수 있다


<br>

## CORS : 교차 오리진 리소스 공유

- Origin : 프로토콜이자 호스트, 도메인, 포트
    - `[https://www.example.com](https://www.example.com)` 이라면?
        - 체계 : HTTP
        - 호스트 : `www.example.com`
        - 포트 : 443
- 리소스를 다른 오리진에서 얻을 수 있다
- 웹 브라우저에는 기본적인 보안으로 CORS를 갖추고 있음 
→ 웹사이트를 방문했을 때 다른 오리진이 허락할 때에만 요청을 보낼 수 있도록 허락하는 설정
    - 브라우저 기반 보안
- `[example.com/one](http://example.com/one)` 과 `[example.com/two](http://example.com/two)` 는 같은 오리진 → 웹 브라우저 간 요청이 가능
- `[www.example.com](http://www.example.com)` 을 방문하여 `[other.example.com](http://other.example.com)` 에 대해 요청할 경우 → 교차 오리진 요청 : 올바른 CORS 헤더가 없으면 웹 브라우저가 해당 요청을 차단
- CORS 헤더 : Access-Control-Allow-Origin이라고 함
- S3 CORS
    - 클라이언트가 웹사이트로 활성화된 S3 버킷에 대해 교차 오리진을 요청하는 경우 올바른 CORS 헤더를 활성화할 필요가 있음 
- CORS 헤더를 활성화해야 하는 시기와 위치에 대해 이해할 필요
    - 전체 오리진 이름을 지정해서 특정 오리진에 대해 허용할 수 있다
    - * 로 모든 오리진을 허용할 수도 있다
    
<br>

## S3 Consistency Model : S3 일관성 모델

- 2020년 12월부터 S3의 모든 작업은 강력한 일관성을 바탕으로 이루어진다
- 아래와 같은 모든 경우마다 방금 작성한 객체를 볼 수 있다
    - 새로운 객체를 성공적으로 S3에 작성
    - 기존 객체를 덮어쓰거나 삭제
    - 작업에 대해 언제나 읽기 혹은 쓰기후 읽기 수행
    - 목록을 작성
- Amazon S3는 강력한 일관성으로 언제나 쓰기/기록후읽기/읽기에 방금 작성한 결과가 바로 반영